# 2025-06-12

## @gaf3

Created this change system.

Currently thinking about some universal process system called Pipes.

The app is actually gonna be called pipelines.

It centers around the journal table and here's how I think we're gonna use it.

- Record create
  - who would be create:{table}.{app}:{id}
  - what would be after: model.export()
- Record update
  - who would be update:{table}.{app}:{id}
  - what would be only differing
    - before: values before update
    - after: values after update
- Record delete
  - who would be delete:{table}.{app}:{id}
  - what would be only differing
    - before: values before deltet
- Query update
  - who would be update:{table}.{app}
  - what would be only differing
    - before: The query run
    - after: What was set
    - count: How many updated
- Query delete
  - who would be delete:{table}.{app}
  - what would be only differing
    - before: The query run
    - count: How many deleted
- And I don't think this can be the universal table at all we don't need that for this

# 2025-06-17

## @gaf3

Created the Journal table in Ledger and updated all DB code to use it.

Now going to replace all the Fact/Act Redis code stream code with Journal changes.

Orginally, I was thinking of having all sorts of buses for all sorts of apps and tables. And maybe
we still will. But for now, now every change to every table goes trough a single method and that
method puts all changes on a single redis stream for journal. Now everything can listen on that one
stream for all changes. We can add all sorts of tables and changes and do virtual tables and all that
and not have to change the code.

I've also added base classes that we can use for all other Apps and Origins. I was already
copy/pasta'ing lots of code back and forth. Let's end that now. There's a module unum_base that has those classes and eventually we'll move it here to lexicon.

Once this is done, we can start cleaning up a lot of code. Rather than spagehttifying everyting so it
just works, which is awesome to start, we cna move to a simplifed and organized framework. Everything
will now respond to changes on the Journal. For eaxmple, a statement is made on Discord, Journal'd exactly
as it with nothing trying to parse it. Something sees there's a new command (query text start with !?*)
and parses it and Journals what it parsed. Then something else sees there's a parsed command and excutes
the command.

This will greater separate concerns in the code. Along those lines, I'm going to split out all the Async
Unum code from Discord and put it into it's Sync class instead. So all the Discord speciic code stays in
Async. It will used the Redis Asyc module. But all the Unum specifc code will be in the Daemon like
everythign else. So when a message is read, it's just Journal'd in the Aysnc. Then the Sycn Daemon will see
there's a command and then parse it. This should all move a lot of code from Discord to Ledger, but we'll
see.

The overall end goal there is to split every module, well, into it's own module. Rather than have one
giant class, I think it'll be easier to split each functionally component into separate classes. That
should lead to less jumping around.
